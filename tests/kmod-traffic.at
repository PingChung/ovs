m4_define([FORMAT_CT], [[grep "dst=$1" | sed -e 's/port=[0-9]*/port=<cleared>/g' -e 's/  */ /g' | cut -d' ' -f4-]])

AT_BANNER([kmod-traffic])

AT_SETUP([kmod - ping between two ports])
OVS_KMOD_VSWITCHD_START(
   [set-fail-mode br0 standalone -- ])

ADD_NAMESPACES(at_ns0, at_ns1)

ADD_VETH(p0, at_ns0, br0, "10.1.1.1/24")
ADD_VETH(p1, at_ns1, br0, "10.1.1.2/24")

AT_CAPTURE_FILE([ping.output])
AT_CHECK([ip netns exec at_ns0 bash -c "ping -q -c 3 -i 0.3 -w 2 10.1.1.2 > ping.output"])

OVS_KMOD_VSWITCHD_STOP([], DEL_NAMESPACES(at_ns0, at_ns1))
AT_CLEANUP

AT_SETUP([conntrack - IPv4 HTTP])
AT_SKIP_IF([test $HAVE_PYTHON = no])
LOAD_MODULES([nf_conntrack_ipv4])
OVS_KMOD_VSWITCHD_START(
   [set-fail-mode br0 standalone -- ])

ADD_NAMESPACES(at_ns0, at_ns1)

ADD_VETH(p0, at_ns0, br0, "10.1.1.1/24")
ADD_VETH(p1, at_ns1, br0, "10.1.1.2/24")

dnl Allow any traffic from ns0->ns1. Only allow nd, return traffic from ns1->ns0.
AT_DATA([flows.txt], [dnl
priority=1,action=drop
priority=10,arp,action=normal
priority=10,icmp,action=normal
in_port=1,tcp,action=ct(commit,zone=0),2
in_port=2,conn_state=-trk,tcp,action=ct(recirc,zone=0)
in_port=2,conn_state=+trk+est-new,tcp,action=1
])

AT_CHECK([ovs-ofctl add-flows br0 flows.txt])

dnl Basic connectivity check.
AT_CHECK([ip netns exec at_ns0 bash -c "ping -q -c 3 -i 0.3 -w 2 10.1.1.2 >/dev/null"])

dnl HTTP requests from ns0->ns1 should work fine.
NETNS_DAEMONIZE([at_ns1], [[$PYTHON $srcdir/test-conntrack.py]], [test-conntrack0.pid])
AT_CHECK([ip netns exec at_ns0 wget 10.1.1.2 -t 5 -T 1 --retry-connrefused -v -o wget0.log])

AT_CHECK([conntrack -L 2>&1 | FORMAT_CT(10.1.1.2)], [0], [dnl
TIME_WAIT src=10.1.1.1 dst=10.1.1.2 sport=<cleared> dport=<cleared> src=10.1.1.2 dst=10.1.1.1 sport=<cleared> dport=<cleared> [[ASSURED]] mark=0 use=1
])

dnl HTTP requests from ns1->ns0 should fail due to network failure.
dnl Try 5 times, in 1 second intervals.
NETNS_DAEMONIZE([at_ns0], [[$PYTHON $srcdir/test-conntrack.py]], [test-conntrack1.pid])
AT_CHECK([ip netns exec at_ns1 wget 10.1.1.1 -t 5 -T 1 -v -o wget1.log], [4])

OVS_KMOD_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([conntrack - IPv6 HTTP])
AT_SKIP_IF([test $HAVE_PYTHON = no])
LOAD_MODULES([nf_conntrack_ipv6])
OVS_KMOD_VSWITCHD_START(
   [set-fail-mode br0 standalone -- ])

ADD_NAMESPACES(at_ns0, at_ns1)

ADD_VETH(p0, at_ns0, br0, "fc00::1/96")
ADD_VETH(p1, at_ns1, br0, "fc00::2/96")

dnl Allow any traffic from ns0->ns1. Only allow nd, return traffic from ns1->ns0.
AT_DATA([flows.txt], [dnl
priority=1,action=drop
priority=10,icmp6,action=normal
in_port=1,tcp6,action=ct(commit,zone=0),2
in_port=2,conn_state=-trk,tcp6,action=ct(recirc,zone=0)
in_port=2,conn_state=+trk+est-new,tcp6,action=1
])

AT_CHECK([ovs-ofctl add-flows br0 flows.txt])

dnl Without this sleep, we get occasional failures due to the following error:
dnl "connect: Cannot assign requested address"
sleep 2;

dnl Basic connectivity check.
AT_CHECK([ip netns exec at_ns0 ping6 -q -c 3 -i 0.3 -w 2 fc00::2 >ping.output])

dnl HTTP requests from ns0->ns1 should work fine.
NETNS_DAEMONIZE([at_ns1], [[$PYTHON $srcdir/test-conntrack.py http6]], [test-conntrack0.pid])

AT_CHECK([ip netns exec at_ns0 wget http://[[fc00::2]] -t 5 -T 1 --retry-connrefused -v -o wget0.log])

dnl HTTP requests from ns1->ns0 should fail due to network failure.
dnl Try 5 times, in 1 second intervals.
NETNS_DAEMONIZE([at_ns0], [[$PYTHON $srcdir/test-conntrack.py http6]], [test-conntrack1.pid])
AT_CHECK([ip netns exec at_ns1 wget http://[[fc00::1]] -t 5 -T 1 -v -o wget1.log], [4])

OVS_KMOD_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([conntrack - invalid])
AT_SKIP_IF([test $HAVE_PYTHON = no])
OVS_KMOD_VSWITCHD_START(
   [set-fail-mode br0 standalone -- ])

ADD_NAMESPACES(at_ns0, at_ns1)

ADD_VETH(p0, at_ns0, br0, "10.1.1.1/24")
ADD_VETH(p1, at_ns1, br0, "10.1.1.2/24")

dnl Allow any traffic from ns0->ns1. Only allow nd, return traffic from ns1->ns0.
AT_DATA([flows.txt], [dnl
priority=1,action=drop
priority=10,arp,action=normal
priority=10,icmp,action=normal
in_port=1,tcp,action=ct(commit,zone=0),2
in_port=2,conn_state=-trk,tcp,action=ct(recirc,zone=0)
in_port=2,conn_state=+trk+inv,tcp,action=1
])

AT_CHECK([ovs-ofctl add-flows br0 flows.txt])

dnl The IPv4 conntrack module is unloaded, so IPv4 traffic should be classed as
dnl "invalid", which our rules will allow.
modprobe -r nf_conntrack_ipv4
NETNS_DAEMONIZE([at_ns1], [[$PYTHON $srcdir/test-conntrack.py]], [test-conntrack0.pid])
AT_CHECK([ip netns exec at_ns0 wget 10.1.1.2 -t 5 -T 1 --retry-connrefused -v -o wget0.log])

OVS_KMOD_VSWITCHD_STOP
AT_CLEANUP
